/* @flow
**/

var EventEmitter = require('events').EventEmitter;
const pg = require('pg');
const Client = pg.Client;
import type {
  ResultSet,
  QueryConfig,
  QueryCallback,
  QueryType,
  PG_ERROR,
} from 'pg';

//you can pass properties to the pool
//these properties are passed unchanged to both the node-postgres Client constructor
//and the node-pool (https://github.com/coopernurse/node-pool) constructor
//allowing you to fully configure the behavior of both
type PgPoolConfig = {
  // node-pool ----------------
  name: string,
  create: Function,
  destroy: Function,
  max: number,
  min: number,
  refreshIdle: boolean,
  idleTimeoutMillis: number,
  reapIntervalMillis: number,
  returnToHead: boolean,
  priorityRange: number,
  validate: Function,
  validateAsync: Function,
  log: Function,

  // node-postgres Client ------
  //database user's name
  user: string,
  //name of database to connect
  database: string,
  //database user's password
  password: string,
  //database port
  port: number,
  // database host. defaults to localhost
  host: string,
  // whether to try SSL/TLS to connect to server. default value: false
  ssl: boolean,
  // name displayed in the pg_stat_activity view and included in CSV log entries
  // default value: process.env.PGAPPNAME
  application_name: string,
  // fallback value for the application_name configuration parameter
  // default value: false
  fallback_application_name: string,

  // pg-pool
  Client: any,
  Promise: any,
  onCreate: Function,
};
type PoolConnectCallback = (err: PG_ERROR|null, client: Client|null, done: DoneCallback) => void;
type DoneCallback = (ifErr?: mixed) => void;
/*
declare class Pool_Client extends Client {
  release(ifErr?: boolean): void;
}
*/
// Do not extends from Client, cause some functions should not be used in
// client returned from Pool.connect. ex: connect and end.
type Pool_Client = {
  release(ifErr?: boolean): void,

  query:
  ( (query: QueryConfig|string, callback?: QueryCallback) => QueryType ) &
  ( (text: string, values: Array<any>, callback?: QueryCallback) => QueryType ),

  on:
  ((event: 'drain', listener: () => void) => EventEmitter )&
  ((event: 'error', listener: (err: PG_ERROR) => void) => EventEmitter )&
  ((event: 'notification', listener: (message: any) => void) => EventEmitter )&
  ((event: 'notice', listener: (message: any) => void) => EventEmitter )&
  ((event: 'end', listener: () => void) => EventEmitter ),
}

declare class Pool extends EventEmitter {
  constructor(options: $Shape<PgPoolConfig>, Client?: Class<Client>): void;
  connect(cb?: PoolConnectCallback): Promise<Pool_Client>;
  take(cb?: PoolConnectCallback): Promise<Pool_Client>;
  end(cb?: DoneCallback): Promise<void>;

// Note: not like the pg's Client, the Pool.query return a Promise,
// not a Thenable Query which Client returned.
  query:
  ( (query: QueryConfig|string, callback?: QueryCallback) => Promise<ResultSet> ) &
  ( (text: string, values: Array<any>, callback?: QueryCallback) => Promise<ResultSet>);

  on:
  ((event: 'connect', listener: (client: Pool_Client) => void) => EventEmitter )&
  ((event: 'acquire', listener: (client: Pool_Client) => void) => EventEmitter )&
  ((event: "error", listener: (err: PG_ERROR) => void) => EventEmitter )&
  ((event: string, listener: Function) => EventEmitter);
}

module.exports = Pool;

export type {
  PgPoolConfig
};
